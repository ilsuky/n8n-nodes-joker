"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateNodesGraph = exports.getNodeTypeForName = void 0;
function getNodeTypeForName(workflow, nodeName) {
    return workflow.nodes.find((node) => node.name === nodeName);
}
exports.getNodeTypeForName = getNodeTypeForName;
function generateNodesGraph(workflow, nodeTypes) {
    const nodesGraph = {
        node_types: [],
        node_connections: [],
        nodes: {},
    };
    const nodeNameAndIndex = {};
    workflow.nodes.forEach((node, index) => {
        var _a, _b, _c, _d, _e, _f;
        nodesGraph.node_types.push(node.type);
        const nodeItem = {
            type: node.type,
            position: node.position,
        };
        if (node.type === 'n8n-nodes-base.httpRequest') {
            try {
                nodeItem.domain = new URL(node.parameters.url).hostname;
            }
            catch (e) {
                nodeItem.domain = node.parameters.url;
            }
        }
        else {
            const nodeType = nodeTypes.getByName(node.type);
            nodeType.description.properties.forEach((property) => {
                if (property.name === 'operation' ||
                    property.name === 'resource' ||
                    property.name === 'mode') {
                    nodeItem[property.name] = property.default ? property.default.toString() : undefined;
                }
            });
            nodeItem.operation = (_b = (_a = node.parameters.operation) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : nodeItem.operation;
            nodeItem.resource = (_d = (_c = node.parameters.resource) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : nodeItem.resource;
            nodeItem.mode = (_f = (_e = node.parameters.mode) === null || _e === void 0 ? void 0 : _e.toString()) !== null && _f !== void 0 ? _f : nodeItem.mode;
        }
        nodesGraph.nodes[`${index}`] = nodeItem;
        nodeNameAndIndex[node.name] = index.toString();
    });
    const getGraphConnectionItem = (startNode, connectionItem) => {
        return { start: nodeNameAndIndex[startNode], end: nodeNameAndIndex[connectionItem.node] };
    };
    Object.keys(workflow.connections).forEach((nodeName) => {
        const connections = workflow.connections[nodeName];
        connections.main.forEach((element) => {
            element.forEach((element2) => {
                nodesGraph.node_connections.push(getGraphConnectionItem(nodeName, element2));
            });
        });
    });
    return { nodeGraph: nodesGraph, nameIndices: nodeNameAndIndex };
}
exports.generateNodesGraph = generateNodesGraph;
//# sourceMappingURL=TelemetryHelpers.js.map