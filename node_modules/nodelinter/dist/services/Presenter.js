"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Presenter = void 0;
var chalk_1 = __importDefault(require("chalk"));
var fs_1 = __importDefault(require("fs"));
var Presenter = /** @class */ (function () {
    function Presenter(config) {
        this.targethasAbsolutePath = false;
        this.config = config;
        this.targethasAbsolutePath = config.target[0] !== ".";
        this.errorBaseColor = this.config.logLevelColors.error
            ? chalk_1.default.hex(this.config.logLevelColors.error)
            : chalk_1.default.redBright;
        this.warningBaseColor = this.config.logLevelColors.warning
            ? chalk_1.default.hex(this.config.logLevelColors.warning)
            : chalk_1.default.yellowBright;
        this.infoBaseColor = this.config.logLevelColors.info
            ? chalk_1.default.hex(this.config.logLevelColors.info)
            : chalk_1.default.blueBright;
    }
    Presenter.prototype.showLogs = function (logs) {
        var _this = this;
        this.showHeader(logs);
        // logs = this.removeRedundantLogs(logs);
        this.logs = this.sortLogs(logs);
        logs.forEach(function (log, index) {
            _this.log = log;
            _this.isLastLog = index === _this.logs.length - 1;
            _this.showMainLine();
            if (_this.config.showDetails && log.details)
                _this.showDetailsLine();
            _this.showExcerptLine();
            _this.showFinalLine();
        });
    };
    // ----------------------------------
    //             header
    // ----------------------------------
    Presenter.prototype.showHeader = function (logs) {
        if (!logs[0])
            return; // file with no lint logs
        var filePath = this.targethasAbsolutePath
            ? logs[0].sourceFilePath.split("/").slice(-3).join("/")
            : logs[0].sourceFilePath;
        var parts = filePath.split("/");
        var _a = __read(__spreadArray([parts.pop()], __read(parts))), fileName = _a[0], basePath = _a.slice(1);
        console.log(" " +
            chalk_1.default.inverse(" \u2022 ") +
            " " +
            chalk_1.default.grey(basePath.join("/")) +
            " \u00BB " +
            chalk_1.default.bold.inverse(" " + fileName + " "));
        console.log(chalk_1.default.grey("  │"));
    };
    // ----------------------------------
    //            main line
    // ----------------------------------
    Presenter.prototype.showMainLine = function () {
        var connector = this.isLastLog ? "└──" : "├──";
        var indentation = " ".repeat(2);
        console.log(indentation +
            chalk_1.default.grey(connector) +
            this.formatLineNumber(this.log.line) +
            this.colorLogAndMessage(this.log.logLevel, this.log.message));
    };
    Presenter.prototype.formatLineNumber = function (line) {
        var zeroPadded = line.toString().padStart(3, "0");
        var whitespacePadded = this.pad(zeroPadded, 5, " ");
        return chalk_1.default.white.inverse(whitespacePadded);
    };
    Presenter.prototype.pad = function (text, length, padChar) {
        if (length === void 0) { length = 11; }
        return text
            .padStart((text.length + length) / 2, padChar)
            .padEnd(length, padChar);
    };
    Presenter.prototype.colorLogAndMessage = function (logLevel, message) {
        var _this = this;
        var color = this.getColor(logLevel);
        var indentationForFirst = " ".repeat(1);
        var indentationForConnector = " ".repeat(2);
        var indentationForRest = " ".repeat(8);
        var logAndMessage = logLevel.toUpperCase() + ": " + message;
        if (message.length > this.config.lineWrapChars) {
            var result = [];
            var _a = __read(this.wrapLines(logAndMessage)), first = _a[0], rest = _a.slice(1);
            result.push(indentationForFirst + color(first));
            result.push.apply(result, __spreadArray([], __read(rest.map(function (line) {
                return indentationForConnector +
                    chalk_1.default.grey(_this.isLastLog ? " " : "│") +
                    indentationForRest +
                    color(line);
            }))));
            return result.join("\n");
        }
        return indentationForFirst + color(logLevel.toUpperCase() + ": " + message);
    };
    // ----------------------------------
    //           details line
    // ----------------------------------
    Presenter.prototype.showDetailsLine = function () {
        if (!this.log.details)
            throw new Error("Something went wrong"); // TODO: Rewrite as assert
        var connector = this.isLastLog ? " " : "│";
        var connectorIndentation = " ".repeat(2);
        var detailsIndentation = " ".repeat(8);
        var showDetailsLine = function (detailsLine) {
            return console.log(connectorIndentation +
                chalk_1.default.grey(connector) +
                detailsIndentation +
                chalk_1.default.white(detailsLine));
        };
        if (this.log.details.length > this.config.lineWrapChars) {
            var wrappedLines = this.wrapLines(this.log.details);
            wrappedLines.forEach(showDetailsLine);
        }
        else {
            showDetailsLine(this.log.details);
        }
    };
    // ----------------------------------
    //           excerpt line
    // ----------------------------------
    Presenter.prototype.showExcerptLine = function () {
        var connector = this.isLastLog ? " " : "│";
        var connectorIndentation = " ".repeat(2);
        var excerptIndentation = " ".repeat(8);
        console.log(chalk_1.default.grey(connectorIndentation + connector + excerptIndentation + this.log.excerpt));
    };
    // ----------------------------------
    //           final line
    // ----------------------------------
    Presenter.prototype.showFinalLine = function () {
        var connector = this.isLastLog ? " " : "│";
        var indentation = " ".repeat(2);
        console.log(chalk_1.default.grey(indentation + connector));
    };
    // ----------------------------------
    //           summary
    // ----------------------------------
    Presenter.prototype.summarize = function (allFilesLogs, executionTimeMs) {
        var errors = 0;
        var warnings = 0;
        var infos = 0;
        allFilesLogs.forEach(function (log) {
            if (log.logLevel === "error")
                errors++;
            if (log.logLevel === "warning")
                warnings++;
            if (log.logLevel === "info")
                infos++;
        });
        this.showSummary({
            errors: errors,
            warnings: warnings,
            infos: infos,
            total: allFilesLogs.length,
            executionTimeMs: executionTimeMs,
        });
    };
    Presenter.prototype.showSummary = function (_a) {
        var total = _a.total, errors = _a.errors, warnings = _a.warnings, infos = _a.infos, executionTimeMs = _a.executionTimeMs;
        var indentation = " ".repeat(2);
        console.log(chalk_1.default.white.bold("Total\t\t" + total));
        console.log(this.getColor("error")(indentation + ("Errors\t" + errors)));
        console.log(this.getColor("warning")(indentation + ("Warnings\t" + warnings)));
        console.log(this.getColor("info")(indentation + ("Infos\t\t" + infos)));
        console.log("Time\t\t" + executionTimeMs + " ms\n");
    };
    // ----------------------------------
    //           line wrapping
    // ----------------------------------
    /**
     * Wrap text into n-chars-long lines, at whitespace chars.
     */
    Presenter.prototype.wrapLines = function (text, result) {
        if (result === void 0) { result = []; }
        if (text.length === 0)
            return result;
        if (text.length < this.config.lineWrapChars || !text.includes(" ")) {
            result.push(text);
            return result;
        }
        var line = text.substring(0, this.config.lineWrapChars).split(" ");
        var remainder = line.pop(); // prevent wrapping mid-word
        result.push(line.join(" "));
        return this.wrapLines((remainder + text).substring(this.config.lineWrapChars), result);
    };
    Presenter.prototype.getColor = function (logLevel, _a) {
        var _b = _a === void 0 ? { thin: false } : _a, thin = _b.thin;
        return {
            error: thin ? this.errorBaseColor : this.errorBaseColor.bold,
            warning: thin ? this.warningBaseColor : this.warningBaseColor.bold,
            info: thin ? this.infoBaseColor : this.infoBaseColor.bold,
        }[logLevel];
    };
    // ----------------------------------
    //         logs preprocessing
    // ----------------------------------
    Presenter.prototype.sortLogs = function (logs) {
        if (this.config.sortMethod === "importance")
            return this.sortByImportance(logs);
        if (this.config.sortMethod === "lineNumber")
            return this.sortByLineNumber(logs);
        throw new Error("Logs may only be sorted by line number or by importance.");
    };
    /**
     * Separate logs based on whether they pass a test.
     */
    Presenter.prototype.separate = function (items, test) {
        var pass = [];
        var fail = [];
        items.forEach(function (item) { return (test(item) ? pass : fail).push(item); });
        return [pass, fail];
    };
    /**
     * Separate an AB group of lintings into those that affect
     * the same line and those that do not.
     *
     * An "AB group of lintings" is an array of lintings that
     * may be of _one of two types only_, i.e. pre-filtered.
     *
     * TODO: Merge with `this.separate()`
     */
    Presenter.prototype.separatePerSameLine = function (logs) {
        var sameLine = [];
        var differentLines = [];
        logs.forEach(function (log, index) {
            if (logs.some(function (sameNameItem, sameNameItemIndex) {
                return sameNameItem.line === log.line && sameNameItemIndex !== index;
            })) {
                sameLine.push(log);
            }
            else {
                differentLines.push(log);
            }
        });
        return [sameLine, differentLines];
    };
    /**
     * Remove logs that are logically covered by other logs on the same line.
     *
     * TODO: Systematize preferences and refactor this logic
     */
    // private removeRedundantLogs(logs: Log[]) {
    //   // prefer NON_STANDARD_RETURNALL_DESCRIPTION over BOOLEAN_DESCRIPTION_NOT_STARTING_WITH_WHETHER
    //   const [returnAllOrWhether, others1] = this.separate(logs, (log) =>
    //     this.isReturnAllOrWhether(log)
    //   );
    //   const [returnAllOrWhetherSameLine, returnAllOrWhetherDifferentLines] =
    //     this.separatePerSameLine(returnAllOrWhether);
    //   if (returnAllOrWhetherSameLine.length === 2) {
    //     logs = [
    //       ...others1,
    //       ...returnAllOrWhetherDifferentLines,
    //       ...returnAllOrWhetherSameLine.filter((log) => this.isReturnAll(log)),
    //     ];
    //   }
    //   // prefer WEAK_PARAM_DESCRIPTION over PARAM_DESCRIPTION_WITH_EXCESS_FINAL_PERIOD
    //   const [weakOrExcess, others2] = this.separate(logs, (log) =>
    //     this.isWeakOrExcess(log)
    //   );
    //   const [weakOrExcessSameLine, weakOrExcessDifferentLines] =
    //     this.separatePerSameLine(weakOrExcess);
    //   if (weakOrExcessSameLine.length === 2) {
    //     logs = [
    //       ...others2,
    //       ...weakOrExcessDifferentLines,
    //       ...weakOrExcessSameLine.filter((log) => this.isWeak(log)),
    //     ];
    //   }
    //   return logs;
    // }
    Presenter.prototype.isReturnAllOrWhether = function (log) {
        return (log.message ===
            this.config.lintings.BOOLEAN_DESCRIPTION_NOT_STARTING_WITH_WHETHER
                .message ||
            log.message ===
                this.config.lintings.NON_STANDARD_RETURNALL_DESCRIPTION.message);
    };
    Presenter.prototype.isReturnAll = function (log) {
        return (log.message ===
            this.config.lintings.NON_STANDARD_RETURNALL_DESCRIPTION.message);
    };
    Presenter.prototype.isWeakOrExcess = function (log) {
        return (log.message === this.config.lintings.WEAK_PARAM_DESCRIPTION.message ||
            log.message ===
                this.config.lintings.PARAM_DESCRIPTION_WITH_EXCESS_FINAL_PERIOD.message);
    };
    Presenter.prototype.isWeak = function (log) {
        return log.message === this.config.lintings.WEAK_PARAM_DESCRIPTION.message;
    };
    Presenter.prototype.sortByImportance = function (logs) {
        var errors = [];
        var warnings = [];
        var infos = [];
        logs.forEach(function (log) {
            if (log.logLevel === "error")
                errors.push(log);
            if (log.logLevel === "warning")
                warnings.push(log);
            if (log.logLevel === "info")
                infos.push(log);
        });
        return __spreadArray(__spreadArray(__spreadArray([], __read(errors)), __read(warnings)), __read(infos));
    };
    Presenter.prototype.sortByLineNumber = function (logs) {
        return logs.sort(function (a, b) { return a.line - b.line; });
    };
    Presenter.printJson = function (fileName, content) {
        fs_1.default.writeFileSync(fileName + ".json", JSON.stringify(content, null, 2));
    };
    return Presenter;
}());
exports.Presenter = Presenter;
