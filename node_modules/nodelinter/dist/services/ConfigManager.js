"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigManager = void 0;
var chalk_1 = __importDefault(require("chalk"));
var minimist_1 = __importDefault(require("minimist"));
var constants_1 = require("../constants");
var utils_1 = require("../utils");
var defaultConfig_1 = require("../defaultConfig");
var __1 = require("..");
var ConfigManager = /** @class */ (function () {
    /**
     * `isNotTestRun` is needed so that tests use `defaultConfig` instead of `customConfig`.
     */
    function ConfigManager(args) {
        this.extractDescriptions = false;
        this.defaultConfig = defaultConfig_1.defaultConfig;
        this.parseArgs(args);
        if (!this.configPath && __1.isNotTestRun)
            this.autoDetectConfigPath();
        if (this.configPath)
            this.loadCustomConfig();
        __1.isNotTestRun && this.validateTargetKeyExists();
        if (this.customConfig) {
            // @ts-ignore TODO
            this.validateNoUnknowns(this.customConfig, { type: "customConfig" });
            this.validateNoTargetKeyConflict();
            this.masterConfig = this.deepMerge(this.defaultConfig, this.customConfig);
            if (this.targetPath)
                this.masterConfig.target = this.targetPath;
        }
        else {
            this.masterConfig = __assign(__assign({}, this.defaultConfig), { target: this.targetPath });
        }
        // overrides
        if (this.only)
            this.overrideLogLevels();
        if (this.patterns)
            this.masterConfig.patterns = this.patterns;
        if (this.extractDescriptions)
            this.masterConfig.extractDescriptions = this.extractDescriptions;
    }
    // ----------------------------------
    //          CLI arg parsers
    // ----------------------------------
    ConfigManager.prototype.parseArgs = function (args) {
        var _a = minimist_1.default(args), _ = _a._, cliArgs = __rest(_a, ["_"]);
        this.parseOnlyArgs({
            "errors-only": cliArgs["errors-only"],
            "warnings-only": cliArgs["warnings-only"],
            "infos-only": cliArgs["infos-only"],
        });
        this.extractDescriptions = cliArgs["extract-descriptions"] !== undefined;
        this.validateNoUnknowns(cliArgs, { type: "cliArgs" });
        this.parsePrintArgs(cliArgs.print);
        this.parsePatternsArgs(cliArgs.patterns);
        if (cliArgs.config)
            this.configPath = cliArgs.config;
        if (cliArgs.target)
            this.targetPath = cliArgs.target;
    };
    ConfigManager.prototype.parseOnlyArgs = function (multiWordArgs) {
        var quantity = Object.values(multiWordArgs).filter(Boolean).length;
        if (quantity === 0)
            return;
        if (quantity > 1)
            utils_1.terminate(constants_1.ERRORS.MULTIPLE_ONLY_ARGS);
        if (quantity === 1) {
            if (multiWordArgs["errors-only"])
                this.only = "error";
            else if (multiWordArgs["warnings-only"])
                this.only = "warning";
            else if (multiWordArgs["infos-only"])
                this.only = "info";
        }
    };
    ConfigManager.prototype.parsePrintArgs = function (print) {
        if (!print)
            return;
        this.printLogs = true;
    };
    ConfigManager.prototype.parsePatternsArgs = function (patterns) {
        if (!patterns)
            return;
        var parsedPatterns = patterns.split(",").map(function (p) { return p.trim(); });
        this.adjustPattern(parsedPatterns, { from: "node.ts", to: ".node.ts" });
        this.adjustPattern(parsedPatterns, {
            from: ".Description.ts",
            to: "Description.ts",
        });
        if (!this.areValidPatterns(parsedPatterns))
            utils_1.terminate(constants_1.ERRORS.INVALID_PATTERNS);
        this.patterns = parsedPatterns;
    };
    ConfigManager.prototype.overrideLogLevels = function () {
        this.masterConfig.enable.logLevels = {
            error: false,
            warning: false,
            info: false,
        };
        this.masterConfig.enable.logLevels[this.only] = true;
    };
    /**
     * Adjust lintable file patterns to tolerate mistypings.
     */
    ConfigManager.prototype.adjustPattern = function (patterns, _a) {
        var from = _a.from, to = _a.to;
        var mistypedPatternIndex = patterns.findIndex(function (p) { return p === from; });
        if (mistypedPatternIndex !== -1) {
            patterns[mistypedPatternIndex] = to;
        }
        return patterns;
    };
    ConfigManager.prototype.areValidPatterns = function (value) {
        return (Array.isArray(value) &&
            value.every(function (item) { return constants_1.LINTABLE_FILE_PATTERNS.includes(item); }));
    };
    // ----------------------------------
    //          arg loaders
    // ----------------------------------
    ConfigManager.prototype.loadCustomConfig = function () {
        try {
            this.customConfig = require(this.configPath);
        }
        catch (error) {
            utils_1.terminate(constants_1.ERRORS.FAILED_TO_IMPORT_CUSTOM_CONFIG);
        }
    };
    ConfigManager.prototype.autoDetectConfigPath = function () {
        console.log(chalk_1.default.dim("No --config option specified, attempting to autodetect...\n"));
        var autodetected = utils_1.collect(process.cwd(), function (f) { return f === constants_1.DEFAULT_AUTODETECT_FILENAME; }).pop();
        if (autodetected) {
            console.log("Custom config autodetected:");
            console.log(chalk_1.default.bold(autodetected + "\n"));
            this.configPath = autodetected;
        }
    };
    /**
     * Validate that the CLI options or the keys in custom config
     * are only those found in the default config.
     *
     * // TODO: Refactor this method
     */
    ConfigManager.prototype.validateNoUnknowns = function (arg, _a) {
        var _this = this;
        var type = _a.type;
        delete arg["errors-only"];
        delete arg["warnings-only"];
        delete arg["infos-only"];
        Object.keys(arg).forEach(function (keyOrOption) {
            if (!__spreadArray(__spreadArray([], __read(Object.keys(_this.defaultConfig))), [
                "print",
                "extract-descriptions",
            ]).includes(keyOrOption)) {
                if (type === "cliArgs") {
                    console.log([
                        chalk_1.default.red.inverse("error".padStart(7, " ").padEnd(9, " ").toUpperCase()),
                        "" + chalk_1.default.bold(constants_1.ERRORS.UNKNOWN_OPTION.title + ":"),
                        constants_1.ERRORS.UNKNOWN_OPTION.message + ":" + " \"--" + keyOrOption + "\"",
                        "\n",
                    ].join(" "));
                }
                else {
                    console.log([
                        chalk_1.default.red.inverse("error".padStart(7, " ").padEnd(9, " ").toUpperCase()),
                        "" + chalk_1.default.bold(constants_1.ERRORS.UNKNOWN_KEY.title + ":"),
                        constants_1.ERRORS.UNKNOWN_KEY.message + ":" + " " + keyOrOption + "\"",
                        "\n",
                    ].join(" "));
                }
                var options = [
                    "--target\t\tPath to the file or dir to lint",
                    "--config\t\tPath to the custom config to use",
                    "--print\t\tWhether to print logs as JSON",
                    "--patterns\t\tPatterns of filenames to lint",
                    "--errors-only\t\tEnable error logs only",
                    "--warnings-only\tEnable warning logs only",
                    "--infos-only\t\tEnable info logs only",
                ];
                console.log(__spreadArray([
                    "Available " + (type === "cliArgs" ? "options" : "keys") + ":"
                ], __read((type === "cliArgs"
                    ? options
                    : options.map(function (option) { return option.slice(2); })).map(function (option, index) {
                    return type === "customConfig" && (index === 2 || index === 5)
                        ? option.replace("\t", "\t\t")
                        : option;
                }))).join("\n  "));
                process.exit(0);
            }
        });
    };
    ConfigManager.prototype.validateTargetKeyExists = function () {
        var _a;
        if (!this.targetPath && !((_a = this.customConfig) === null || _a === void 0 ? void 0 : _a.target)) {
            utils_1.terminate(constants_1.ERRORS.UNSPECIFIED_TARGET);
        }
    };
    /**
     * Validate that a single target exists, either
     * - the `--target` CLI arg, i.e. `this.targetPath` or
     * - the `target` key in the custom config, i.e. `this.customConfig.target`.
     */
    ConfigManager.prototype.validateNoTargetKeyConflict = function () {
        if (this.customConfig.target && this.targetPath) {
            utils_1.terminate(constants_1.ERRORS.OVERSPECIFIED_TARGET);
        }
    };
    // TODO: Type properly
    ConfigManager.prototype.deepMerge = function () {
        var e_1, _a, e_2, _b, _c, _d;
        var objects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            objects[_i] = arguments[_i];
        }
        var result = {};
        try {
            for (var objects_1 = __values(objects), objects_1_1 = objects_1.next(); !objects_1_1.done; objects_1_1 = objects_1.next()) {
                var o = objects_1_1.value;
                try {
                    for (var _e = (e_2 = void 0, __values(Object.entries(o))), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var _g = __read(_f.value, 2), key = _g[0], value = _g[1];
                        if (value instanceof Array) {
                            result = __assign(__assign({}, result), (_c = {}, _c[key] = value, _c));
                            continue;
                        }
                        if (value instanceof Object && key in result) {
                            value = this.deepMerge(result[key], value);
                        }
                        result = __assign(__assign({}, result), (_d = {}, _d[key] = value, _d));
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (objects_1_1 && !objects_1_1.done && (_a = objects_1.return)) _a.call(objects_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return result;
    };
    // ----------------------------------
    //         state reporting
    // ----------------------------------
    // TODO: Refactor to remove repetition
    ConfigManager.lintAreaIsDisabled = function (lintArea, config) {
        return !config.enable.lintAreas[lintArea];
    };
    ConfigManager.lintIssueIsDisabled = function (lintIssue, config) {
        return !config.enable.lintIssues[lintIssue];
    };
    ConfigManager.logLevelIsDisabled = function (logLevel, config) {
        return !config.enable.logLevels[logLevel];
    };
    ConfigManager.lintingIsDisabled = function (linting, config) {
        var configLinting = utils_1.getLinting(linting, config.lintings);
        if (!configLinting) {
            throw new Error("No config linting found for: " + linting.message);
        }
        return !configLinting.enabled;
    };
    /**
     * Report whether a linting at a line is disabled by an exception comment.
     */
    ConfigManager.lintingIsExcepted = function (linting, lintingLine, exceptions, masterConfig) {
        var found = exceptions.find(function (_a) {
            var lintingsToExcept = _a.lintingsToExcept, line = _a.line;
            var lintingName = utils_1.getLintingName(linting, masterConfig);
            var lintingsMatch = lintingsToExcept.includes(lintingName) ||
                lintingsToExcept.includes("*");
            return lintingsMatch && line + 1 === lintingLine;
        });
        return found !== undefined;
    };
    return ConfigManager;
}());
exports.ConfigManager = ConfigManager;
